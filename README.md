
# NetCommander

NetCommander is a client-server program developed in C language as part of the DV1457/DV1578 Lab 3 for the 2022 fall semester of lp1. The project focuses on implementing a server capable of handling multiple client connections concurrently. It supports two distinct operations: matrix inversion and k-means clustering. You can also run any command in the server from the client but the code needs some modifications in it. I have my code designed to mainly run the executable files so it always adds "./" to the commands sent to the server by the client and then executes it.

## Project Structure

The project structure adheres to the following directory layout:

```
├── Client1
│   ├── client.c
│   ├── kmeans-data.txt
│   └── results
├── LICENSE
├── makefile
├── mathserver
│   ├── computed_results
│   ├── include
│   │   ├── kmeans.h
│   │   └── matrix_inverse.h
│   ├── objects
│   └── src
│       ├── kmeans.c
│       ├── kmeans-viz.py
│       ├── matrix_inverse.c
│       └── server.c
└── README.md
```

- The `mathserver` folder contains server-related source files.
- Header files are placed in the `include` folder, source code files in the `src` folder, and object files in the `objects` folder.
- The `client` folder contains all client-related files.
- The `computed_results` directory stores results generated by the server.
- The `results` folder holds individual client result directories.

## Building and Running

To build the project, execute the following commands in the project root directory:

```bash
make
```

This will compile the server and client programs, placing the final executables in the project folder.

### Running the Server

To start the server on a specified port (e.g., 9999), use the following command:

I am using mainly fork because I have tested this more, I also have muxbasic and muxscale code in place but it needs some testing.
```bash
./server -p 9999 fork
```

The server will listen for incoming client connections.

### Running a Client

To connect a client to the server, use the following command:

```bash
./client -ip <server_ip> -p <server_port>
```

Once connected, the client can send commands and receive results from the server.

## Command Line Options

The server supports the following command-line options:

- `-h`: Print help text
- `-p port`: Listen on the specified port number
- `-d`: Run as a daemon
- `-s strategy`: Specify the request handling strategy (fork, muxbasic, muxscale)

The `matinv-par.c` and `kmeans-par.c` files must support all the command-line options supported by the sequential code.

## Concurrent Client Handling

The server efficiently handles multiple client sessions concurrently using strategies like fork, muxbasic, or muxscale.

## Implementation of Mathematical Operations

### Matrix Inversion

The server calculates the inverse of a matrix using Gauss-Jordan elimination. The provided `matrix_inverse.c` program can be compiled and executed as follows:

```bash
gcc -w -O2 -o matinv matrix_inverse.c
./matinv -n 4 -P 1 -I fast
```
The server supports matrix inversion using the Gauss-Jordan elimination method. The client can send a matrix inversion command to the server, and the server computes and returns the inverted matrix. Matrix inversion is optimised using threads and you can initialize a matrix with nearly 2048x2048 size without in few seconds and then send the file as well without any transfer issues.

```bash
matinvpar -n 8 -I fast -P 1
```
#### Command:
```bash
matinvpar -n <size> -I <init_type> -P <num_threads>
```

#### Flags:

- `-n <size>`: Specifies the size of the matrix to be inverted. Example: `-n 8` for a size 8x8 matrix.

- `-I <init_type>`: Specifies the initialization method for the matrix. Possible values for `<init_type>` include:
  - `fast`: Fast initialization.
  - `rand`: Random initialization.

- `-P <num_threads>`: Specifies the number of threads to be used for parallelization during matrix inversion.

#### Example:
```bash
matinvpar -n 8 -I fast -P 1
```

This example command requests the inversion of an 8x8 matrix using fast initialization with a single thread.


### k-means Clustering

The k-means clustering algorithm is implemented to group data points into specified clusters. The provided `kmeans.c` program can be compiled and executed as follows:


```bash
gcc -w -O2 -o kmeans kmeans.c
./kmeans
python3 kmeans-viz.py
```
The server implements the k-means clustering algorithm for grouping data points into specified clusters. The client sends a k-means command with the data file, and the server computes and returns the cluster assignments.

```bash
kmeanspar -f kmeans-data.txt -k 9
```

#### Command:
```bash
kmeanspar -f <data_file> -k <num_clusters>
```

#### Flags:

- `-f <data_file>`: Specifies the path to the file containing the problem data for k-means clustering. Example: `-f kmeans-data.txt`.

- `-k <num_clusters>`: Specifies the number of clusters for k-means clustering.

#### Example:
```bash
kmeanspar -f kmeans-data.txt -k 9
```

This example command performs k-means clustering using the data in the file `kmeans-data.txt` with 9 clusters.


## Contributing

Contributions to the project are welcome. Feel free to submit bug reports, feature requests, or pull requests to enhance the functionality.

